# Javascript

::: details 什么是闭包，有什么用途和弊端

```
// 1. 闭包是指有权访问另一个函数作用域中的变量的函数。--js高级程序设计

// 2. 闭包是由函数和声明该函数的词法环境组成，这个环境包含了闭包创建时作用域内的任何局部变量

function foo() {
    const str = "sss";
    function bar() {
        console.log(str);
    }
    return bar;
}


```

用途：

-   模块化
-   封装私有变量
-   保存函数执行上下文

弊端

-   内存泄漏
-   变量共享
-   性能消耗

:::

::: details this 的指向
一般说来 this 是指函数的调用运行时的调用者，细分：

-   普通函数中的 this --Window
-   对象调用
-   call、apply、bind
-   new 绑定（构造函数调用）
-   箭头函数
-   DOM 事件处理函数中

:::



::: details ES5/ES6 在继承上有哪些区别

- 默认绑定
- 隐式绑定
- 显式绑定
- new绑定

| 特性           | ES5 继承                                           | ES6 继承                                                      |
| -------------- | -------------------------------------------------- | ------------------------------------------------------------- |
| 语法           | 使用构造函数和原型链实现继承                       | 使用 `class` 和 `extends` 关键字实现继承                      |
| 构造函数调用   | 需要手动调用父类构造函数（如 `Parent.call(this)`） | 使用 `super()` 自动调用父类构造函数                           |
| 原型方法定义   | 在 `prototype` 上定义方法                          | 在 `class` 内部直接定义方法                                   |
| 静态方法       | 直接在构造函数上定义静态方法                       | 使用 `static` 关键字定义静态方法                              |
| 继承链         | 基于原型链的继承                                   | 基于类的继承                                                  |
| 可读性         | 语法较为复杂，可读性较低                           | 语法简洁，可读性较高                                          |
| 兼容性         | 兼容所有支持 ES5 的浏览器                          | 需要支持 ES6 的浏览器                                         |
| 私有属性和方法 | 无法直接实现私有属性和方法                         | 无法直接实现私有属性和方法（可通过 `#` 实现提案中的私有字段） |
| 多继承         | 不支持多继承                                       | 不支持多继承                                                  |
| 实例化         | 使用 `new` 关键字实例化对象                        | 使用 `new` 关键字实例化对象                                   |

:::

::: details js中的消息队列和事件循环

在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

- 执行一个宏任务（栈中没有就从事件队列中获取）
- 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中
- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）
- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）

https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7
:::
